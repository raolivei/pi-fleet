---
# =============================================================================
# CRITICAL: CONNECTIVITY SAFETY
# =============================================================================
# This playbook is designed to NEVER break connectivity to nodes.
# All network, hostname, and firewall changes include:
# - Pre-flight checks (gateway reachability, current IP connectivity)
# - Validation before application (dry-run, syntax checks)
# - Post-change verification (connectivity tests, IP verification)
# - Automatic rollback instructions if something goes wrong
# - Never modifies existing static network configurations
# =============================================================================
- name: Complete System Setup for Eldertree Raspberry Pi
  hosts: raspberry_pi
  become: true
  vars:
    target_user: raolivei
    # Password should be set via Ansible Vault or environment variable
    # Use: ansible-playbook --ask-vault-pass or set env_target_password environment variable
    target_password: "{{ vault_target_password | default(lookup('env', 'env_target_password') | default('CHANGE_ME')) }}"
    # CRITICAL: Hostname MUST be FQDN (node-X.eldertree.local) - NEVER use just "eldertree"
    # Default to inventory_hostname + '.eldertree.local' pattern
    # Can be overridden via -e hostname=node-X.eldertree.local
    hostname: "{{ hostname_override | default(inventory_hostname + '.eldertree.local') }}"
    # Static IP configuration
    # Pattern: node-0 = 192.168.2.80, node-1 = 192.168.2.81, node-2 = 192.168.2.82, etc.
    # Set to empty string "" to use DHCP
    static_ip: "{{ static_ip_override | default('') }}"
    static_netmask: "255.255.255.0"
    static_gateway: "192.168.2.1"
    static_dns: ["192.168.2.1", "8.8.8.8"]
    backup_device: "/dev/sdb1"
    backup_mount: "/mnt/backup"
    password_hash: "{{ target_password | password_hash('sha512') }}"

  pre_tasks:
    # Handle generic "node-x" hostname from Raspberry Pi Imager SD cards
    # Convert to proper node-X.eldertree.local based on inventory_hostname
    # Example: If connecting to "node-1" in inventory and actual hostname is "node-x", convert to "node-1.eldertree.local"
    # Example: If connecting to "node-2" in inventory and actual hostname is "node-x", convert to "node-2.eldertree.local"
    - name: Detect generic node-x hostname from SD card
      shell: hostname
      register: current_hostname_raw
      changed_when: false

    - name: Extract node number from inventory_hostname (e.g., "node-1" -> "1", "node-2" -> "2")
      set_fact:
        node_number: "{{ inventory_hostname | regex_replace('^node-', '') }}"
      changed_when: false

    - name: Set proper hostname if current is generic "node-x" (convert to node-X.eldertree.local based on inventory)
      set_fact:
        hostname: "{{ 'node-' + node_number + '.eldertree.local' }}"
      when: current_hostname_raw.stdout == "node-x"

    # CRITICAL: Validate hostname is FQDN format (node-X.eldertree.local)
    # This prevents accidentally setting hostname to just "eldertree"
    - name: Validate hostname format
      fail:
        msg: |
          CRITICAL ERROR: Hostname must be in FQDN format (node-X.eldertree.local), not just "eldertree"!
          Current hostname value: {{ hostname }}
          This is a safety check to prevent cluster naming conflicts.
          Use: -e hostname=node-0.eldertree.local (or let it default from inventory_hostname)
      when: hostname == "eldertree" or (hostname is defined and hostname != "" and ".eldertree.local" not in hostname)

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install essential packages
      apt:
        name:
          - curl
          - wget
          - git
          - vim
          - htop
          - iptables
          - ufw
          - bluez
          - bluez-tools
          - bluetooth
          - openssh-server
          - sudo
          - rsync
          - tmux
        state: present

    # =========================================================================
    # User Configuration
    # =========================================================================
    - name: Check if user {{ target_user }} exists
      getent:
        database: passwd
        key: "{{ target_user }}"
      register: user_check
      failed_when: false
      changed_when: false

    - name: Fail if user does not exist (should be created via Raspberry Pi Imager)
      fail:
        msg: |
          User {{ target_user }} does not exist. Please create it via Raspberry Pi Imager:
          1. Use Raspberry Pi Imager to create SD card
          2. Enable SSH and set username to {{ target_user }}
          3. Configure SSH key in Imager settings
      when: user_check.ansible_facts.getent_passwd[target_user] is not defined

    - name: Ensure user {{ target_user }} is in sudo group
      user:
        name: "{{ target_user }}"
        groups: sudo
        append: yes

    - name: Configure passwordless sudo for {{ target_user }}
      lineinfile:
        path: /etc/sudoers.d/{{ target_user }}
        line: "{{ target_user }} ALL=(ALL) NOPASSWD: ALL"
        create: yes
        validate: "visudo -cf %s"
        mode: "0440"
        owner: root
        group: root

    - name: Ensure home directory has correct permissions
      file:
        path: /home/{{ target_user }}
        owner: "{{ target_user }}"
        group: "{{ target_user }}"
        mode: "0755"
        state: directory

    # =========================================================================
    # Hostname Configuration
    # =========================================================================
    # CRITICAL: Always use FQDN format (node-X.eldertree.local)
    # Short hostname is derived from inventory_hostname (node-0, node-1, etc.)
    - name: Get current hostname
      command: hostname
      register: current_hostname_check
      changed_when: false

    - name: Set full hostname (FQDN) - only if different
      hostname:
        name: "{{ hostname }}"
      when: current_hostname_check.stdout != hostname

    - name: Read current /etc/hostname
      slurp:
        src: /etc/hostname
      register: current_hostname_file
      failed_when: false
      changed_when: false

    - name: Update /etc/hostname with full hostname - only if different
      copy:
        content: "{{ hostname }}\n"
        dest: /etc/hostname
        mode: "0644"
      when: current_hostname_file.content | default('') | b64decode | trim != hostname

    - name: Read current /etc/hosts entry
      shell: grep '^127\.0\.1\.1' /etc/hosts || echo ""
      register: current_hosts_entry
      changed_when: false
      failed_when: false

    - name: Update /etc/hosts with full hostname and short name - only if different
      lineinfile:
        path: /etc/hosts
        regexp: '^127\.0\.1\.1.*'
        line: "127.0.1.1 {{ hostname }} {{ inventory_hostname }}"
        state: present
      when: current_hosts_entry.stdout != ("127.0.1.1 " + hostname + " " + inventory_hostname)

    # =========================================================================
    # Network Configuration (Static IP - Optional)
    #
    # Design: Resilient, Safe, Idempotent
    # - Only configures DHCP → Static (never changes existing static configs)
    # - Requires gateway reachability before making changes
    # - Validates configuration before applying
    # - Preserves working network configurations
    # =========================================================================
    - name: Configure static IP (if specified)
      block:
        - name: Check if using Netplan (Ubuntu/Debian)
          stat:
            path: /etc/netplan
          register: netplan_dir

        - name: Gather network state
          block:
            - name: Get current eth0 IP
              shell: ip -4 addr show eth0 | grep -oP 'inet \K[\d.]+' || echo ""
              register: current_ip
              changed_when: false
              failed_when: false

            - name: Test gateway connectivity
              shell: ping -c 1 -W 2 {{ static_gateway }} >/dev/null 2>&1 && echo "ok" || echo "fail"
              register: gateway_reachable
              changed_when: false
              failed_when: false

            - name: Test current IP connectivity (safety check)
              shell: ping -c 1 -W 2 {{ current_ip.stdout }} >/dev/null 2>&1 && echo "ok" || echo "fail"
              register: current_ip_reachable
              changed_when: false
              failed_when: false
              when: current_ip.stdout != ""

            - name: Detect network mode
              shell: |
                for file in /etc/netplan/*.yaml; do
                  [ -f "$file" ] && grep -q "dhcp4:.*yes" "$file" && echo "dhcp" && exit 0
                done
                echo "static"
              register: network_mode
              changed_when: false
              failed_when: false

          when: netplan_dir.stat.exists

        - name: Display network state
          debug:
            msg:
              - "Network: IP={{ current_ip.stdout | default('none') }}, Mode={{ network_mode.stdout | default('unknown') }}, Gateway={{ 'reachable' if gateway_reachable.stdout == 'ok' else 'unreachable' }}"
          when: netplan_dir.stat.exists

        - name: Skip - Gateway unreachable
          debug:
            msg: "⚠️  Skipping - gateway unreachable (preserving connectivity)"
          when:
            - netplan_dir.stat.exists
            - gateway_reachable.stdout != "ok"

        - name: Skip - Current IP unreachable (safety check)
          debug:
            msg: "⚠️  Skipping - current IP unreachable (preserving connectivity)"
          when:
            - netplan_dir.stat.exists
            - current_ip.stdout != ""
            - current_ip_reachable.stdout != "ok"

        - name: Skip - Already configured
          debug:
            msg: "✓ Already configured - IP: {{ current_ip.stdout }}"
          when:
            - netplan_dir.stat.exists
            - gateway_reachable.stdout == "ok"
            - current_ip.stdout == static_ip

        - name: Skip - Already static
          debug:
            msg: "⚠️  Skipping - already using static IP (preserving working config)"
          when:
            - netplan_dir.stat.exists
            - gateway_reachable.stdout == "ok"
            - current_ip.stdout != static_ip
            - network_mode.stdout == "static"

        - name: Configure static IP (DHCP → Static) - SAFE MODE
          block:
            - name: Backup current Netplan configuration
              shell: |
                BACKUP_DIR="/root/netplan-backups"
                mkdir -p "$BACKUP_DIR"
                BACKUP_FILE="$BACKUP_DIR/netplan-backup-$(date +%Y%m%d-%H%M%S).tar.gz"
                tar -czf "$BACKUP_FILE" /etc/netplan/*.yaml 2>/dev/null || true
                echo "$BACKUP_FILE"
              register: netplan_backup
              changed_when: false

            - name: Create Netplan configuration
              copy:
                dest: /etc/netplan/01-eth0-static.yaml
                content: |
                  network:
                    version: 2
                    renderer: networkd
                    ethernets:
                      eth0:
                        dhcp4: no
                        addresses:
                          - {{ static_ip }}/24
                        routes:
                          - to: default
                            via: {{ static_gateway }}
                        nameservers:
                          addresses: {{ static_dns }}
                backup: yes
                mode: "0600"

            - name: Validate configuration (dry-run)
              command: netplan generate
              register: netplan_validate
              changed_when: false
              failed_when: netplan_validate.rc != 0

            - name: Fail if validation failed
              fail:
                msg: "Netplan configuration validation failed! Configuration NOT applied. Check syntax. Backup: {{ netplan_backup.stdout }}"
              when: netplan_validate.rc != 0

            - name: Apply configuration
              command: netplan apply
              register: netplan_apply
              when: netplan_validate.rc == 0

            - name: Wait for network stabilization
              pause:
                seconds: 5
              when: netplan_apply.changed | default(false)

            - name: Verify new IP is assigned
              shell: ip -4 addr show eth0 | grep -oP 'inet \K[\d.]+' || echo ""
              register: new_ip
              changed_when: false
              failed_when: false
              when: netplan_apply.changed | default(false)

            - name: Verify new IP matches target
              fail:
                msg: "Network configuration failed! New IP ({{ new_ip.stdout }}) does not match target ({{ static_ip }}). Restore from backup: {{ netplan_backup.stdout }}"
              when:
                - netplan_apply.changed | default(false)
                - new_ip.stdout != static_ip

            - name: Test connectivity after network change
              shell: |
                # Test gateway
                ping -c 1 -W 2 {{ static_gateway }} >/dev/null 2>&1 && echo "gateway_ok" || echo "gateway_fail"
                # Test DNS
                ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1 && echo "dns_ok" || echo "dns_fail"
              register: connectivity_test
              changed_when: false
              failed_when: false
              when: netplan_apply.changed | default(false)

            - name: Fail if connectivity lost
              fail:
                msg: "CRITICAL: Connectivity lost after network change! Gateway: {{ connectivity_test.stdout | regex_search('gateway_\\w+') }}, DNS: {{ connectivity_test.stdout | regex_search('dns_\\w+') }}. Restore from backup: {{ netplan_backup.stdout }}"
              when:
                - netplan_apply.changed | default(false)
                - "gateway_fail" in connectivity_test.stdout or "dns_fail" in connectivity_test.stdout

            - name: Display success
              debug:
                msg: "✅ Network configured safely: {{ new_ip.stdout }} (DHCP → Static). Connectivity verified."
              when: netplan_apply.changed | default(false)

          when:
            - netplan_dir.stat.exists
            - gateway_reachable.stdout == "ok"
            - current_ip.stdout != static_ip
            - network_mode.stdout == "dhcp"
            - current_ip_reachable.stdout == "ok" or current_ip.stdout == ""

      when: static_ip is defined and static_ip != ""

    # =========================================================================
    # Bluetooth Configuration
    # =========================================================================
    - name: Enable Bluetooth service
      systemd:
        name: bluetooth
        enabled: yes
        state: started

    - name: Check Bluetooth status
      command: systemctl status bluetooth
      register: bluetooth_status
      changed_when: false
      failed_when: false

    - name: Display Bluetooth status
      debug:
        msg: "{{ bluetooth_status.stdout_lines }}"

    # =========================================================================
    # Backup Mount Configuration
    # =========================================================================
    - name: Create backup mount directory
      file:
        path: "{{ backup_mount }}"
        state: directory
        mode: "0755"

    - name: Check if backup device exists in fstab
      shell: grep "{{ backup_device }}" /etc/fstab || echo "not_found"
      register: fstab_check
      changed_when: false
      failed_when: false

    - name: Add backup mount to fstab with nofail option (if not exists)
      lineinfile:
        path: /etc/fstab
        line: "{{ backup_device }} {{ backup_mount }} ext4 defaults,nofail 0 2"
        state: present
        backup: yes
      when: "'not_found' in fstab_check.stdout"

    - name: Update existing fstab entry to include nofail
      replace:
        path: /etc/fstab
        regexp: '^({{ backup_device }}[^\s]+)\s+([^\s]+)\s+(ext4)\s+([^,\s]+)(.*?)(\s+\d+\s+\d+)$'
        replace: '\1 \2 \3 \4,nofail\5\6'
        backup: yes
      when: "'not_found' not in fstab_check.stdout and 'nofail' not in fstab_check.stdout"

    # =========================================================================
    # SSH Configuration
    # Note: SSH keys are configured via Raspberry Pi Imager
    # We only ensure SSH service is running and apply basic hardening
    # =========================================================================
    - name: Ensure SSH service is enabled and started
      systemd:
        name: ssh
        enabled: yes
        state: started

    - name: Configure SSH hardening (optional)
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        backup: yes
      loop:
        - {regexp: "^#?PermitRootLogin", line: "PermitRootLogin no"}
        - {regexp: "^#?PasswordAuthentication", line: "PasswordAuthentication yes"}
        - {regexp: "^#?PubkeyAuthentication", line: "PubkeyAuthentication yes"}
      notify: restart ssh

    # =========================================================================
    # Firewall Configuration
    # CRITICAL: SSH must ALWAYS be allowed. All firewall changes ensure SSH access.
    # =========================================================================
    - name: Ensure UFW is installed
      apt:
        name: ufw
        state: present

    - name: Check current UFW status
      shell: ufw status | head -1 || echo "inactive"
      register: ufw_status
      changed_when: false
      failed_when: false

    - name: Check if SSH is already allowed
      shell: ufw status | grep -q "OpenSSH.*ALLOW" && echo "yes" || echo "no"
      register: ssh_allowed
      changed_when: false
      failed_when: false

    - name: Ensure SSH is allowed BEFORE any firewall changes
      ufw:
        rule: allow
        name: OpenSSH
        state: enabled
      when: ssh_allowed.stdout == "no"

    - name: Verify SSH rule is active
      shell: ufw status | grep -q "OpenSSH.*ALLOW" && echo "ok" || echo "fail"
      register: ssh_verify
      changed_when: false
      failed_when: false

    - name: Fail if SSH is not allowed
      fail:
        msg: "CRITICAL: SSH is not allowed in firewall! This would break connectivity. Manual intervention required."
      when: ssh_verify.stdout == "fail"

    - name: Reset UFW to defaults (DISABLED - only enable if absolutely necessary)
      ufw:
        state: reset
      when: false # Disabled by default - enable if needed (WARNING: This can break connectivity!)

    - name: Enable UFW (optional - disabled by default)
      ufw:
        state: enabled
      when: false # Disabled by default - enable if needed

    # =========================================================================
    # System Optimization
    # =========================================================================
    - name: Get cmdline.txt content
      set_fact:
        cmdline_content: "{{ lookup('file', '/boot/firmware/cmdline.txt', errors='ignore') | default('') | string }}"
      changed_when: false
      failed_when: false

    - name: Configure cgroups for containers
      lineinfile:
        path: /boot/firmware/cmdline.txt
        regexp: "cgroup_memory=1 cgroup_enable=memory"
        line: " cgroup_memory=1 cgroup_enable=memory"
        backrefs: yes
        state: present
      when: cmdline_content is defined and 'cgroup_memory=1' not in cmdline_content

    - name: Set timezone
      timezone:
        name: America/Toronto

    - name: Configure NTP
      systemd:
        name: systemd-timesyncd
        enabled: yes
        state: started

    # =========================================================================
    # Summary
    # =========================================================================
    - name: Display configuration summary
      debug:
        msg:
          - "=== System Configuration Complete ==="
          - "Hostname: {{ hostname }}"
          - "User: {{ target_user }}"
          - "Static IP: {{ static_ip if static_ip else 'DHCP' }}"
          - "Bluetooth: Enabled"
          - "Backup mount: {{ backup_mount }} (nofail configured)"
          - "Diagnostic files: Cleaned up"
          - ""
          - "Next steps:"
          - "1. Install k3s: ansible-playbook playbooks/install-k3s.yml"
          - "2. Bootstrap FluxCD GitOps: ansible-playbook playbooks/bootstrap-flux.yml -e bootstrap_flux=true"
          - "3. Deploy applications"

  handlers:
    - name: restart ssh
      systemd:
        name: sshd
        state: restarted
