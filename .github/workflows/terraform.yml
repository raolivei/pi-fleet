name: "Terraform"

on:
  push:
    branches: ["main"]
    paths:
      - "terraform/**"
      - ".github/workflows/terraform.yml"
  pull_request:
    paths:
      - "terraform/**"
      - ".github/workflows/terraform.yml"
  workflow_dispatch:
    inputs:
      apply:
        description: "Apply Terraform changes"
        required: false
        default: false
        type: boolean

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  # Cloudflare
  TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
  TF_VAR_cloudflare_origin_ca_key: ${{ secrets.CLOUDFLARE_ORIGIN_CA_KEY }}
  TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
  TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
  TF_VAR_pitanga_cloud_zone_id: ${{ vars.PITANGA_CLOUD_ZONE_ID }}
  TF_VAR_swimto_app_zone_id: ${{ vars.SWIMTO_APP_ZONE_ID }}
  TF_VAR_raolivei_com_zone_id: ${{ vars.RAOLIVEI_COM_ZONE_ID }}
  TF_VAR_public_ip: ${{ secrets.PUBLIC_IP }}
  # Skip k3s (managed by Ansible)
  TF_VAR_skip_k3s_resources: "true"
  # Vault: use local dev server started in CI (see "Start Vault" step)
  # This prevents the Vault provider plugin from crashing and keeps
  # vault_enabled=true so existing vault resources aren't planned for destruction
  TF_VAR_skip_vault_resources: "false"
  TF_VAR_vault_token: "ci-root"
  TF_VAR_vault_address: "http://127.0.0.1:8200"
  TF_VAR_kubeconfig_path: "~/.kube/config-eldertree"
  TF_VAR_pi_user: ${{ secrets.PI_USER }}

jobs:
  terraform:
    name: "Terraform"
    runs-on: ubuntu-latest
    environment: dev

    services:
      vault:
        image: hashicorp/vault:1.15
        env:
          VAULT_DEV_ROOT_TOKEN_ID: ci-root
          VAULT_DEV_LISTEN_ADDRESS: 0.0.0.0:8200
        ports:
          - 8200:8200
        options: >-
          --cap-add=IPC_LOCK

    defaults:
      run:
        shell: bash
        working-directory: terraform

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          cli_config_credentials_hostname: app.terraform.io
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      # Pre-configure Vault dev server with backends that exist in TF state
      # so the provider doesn't crash during PlanResourceChange calls
      - name: Configure Vault Dev Server
        run: |
          # Wait for Vault to be ready
          for i in 1 2 3 4 5; do
            curl -sf http://127.0.0.1:8200/v1/sys/health && break
            echo "Waiting for Vault... ($i)"
            sleep 2
          done
          # Enable kubernetes auth backend (kv-v2 at secret/ is default in dev)
          curl -sf --header "X-Vault-Token: ci-root" \
            --request POST \
            --data '{"type":"kubernetes"}' \
            http://127.0.0.1:8200/v1/sys/auth/kubernetes || true
        working-directory: .

      - name: Terraform Init
        run: terraform init -input=false

      # Redirect to file (not pipe) to avoid EPIPE crash in setup-terraform wrapper
      - name: Verify Remote State
        run: |
          if terraform state list > state-list.txt 2>&1; then
            STATE_COUNT=$(wc -l < state-list.txt | tr -d ' ')
            echo "✅ Remote state: $STATE_COUNT resources"
            head -20 state-list.txt
            [ "$STATE_COUNT" -gt 20 ] && echo "... and $((STATE_COUNT - 20)) more"
            if [ "$STATE_COUNT" -eq "0" ]; then
              echo "❌ State is empty"
              exit 1
            fi
          else
            echo "❌ Could not access remote state"
            cat state-list.txt 2>/dev/null || true
            exit 1
          fi
          rm -f state-list.txt

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      # -refresh=false: use cached state, don't refresh from providers
      # Vault dev server satisfies provider init; -refresh=false avoids state drift
      - name: Terraform Plan
        id: plan
        run: |
          set +e
          terraform plan -input=false -refresh=false -detailed-exitcode > plan-output.txt 2>&1
          PLAN_EXIT_CODE=$?
          set -e
          cat plan-output.txt
          echo ""
          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "✅ No changes needed"
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "✅ Changes detected"
            grep -A 5 "Plan:" plan-output.txt || true
          else
            echo "❌ Plan failed (exit code $PLAN_EXIT_CODE)"
            exit 1
          fi

      - name: Terraform Apply
        if: |
          steps.plan.outcome == 'success' && 
          (github.event_name == 'workflow_dispatch' && github.event.inputs.apply == 'true')
        run: terraform apply -auto-approve -input=false -refresh=false
