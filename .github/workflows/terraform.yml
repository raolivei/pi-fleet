name: "Terraform"

on:
  push:
    branches: ["main"]
    paths:
      - "terraform/**"
      - ".github/workflows/terraform.yml"
  pull_request:
    paths:
      - "terraform/**"
      - ".github/workflows/terraform.yml"
  workflow_dispatch:
    inputs:
      apply:
        description: "Apply Terraform changes"
        required: false
        default: false
        type: boolean

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# Shared env block for all Terraform variables
# Secrets: sensitive credentials (from GitHub Secrets)
# Vars: non-sensitive config (from GitHub Variables)
env:
  TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
  TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
  TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
  TF_VAR_pitanga_cloud_zone_id: ${{ vars.PITANGA_CLOUD_ZONE_ID }}
  TF_VAR_swimto_app_zone_id: ${{ vars.SWIMTO_APP_ZONE_ID }}
  TF_VAR_raolivei_com_zone_id: ${{ vars.RAOLIVEI_COM_ZONE_ID }}
  TF_VAR_public_ip: ${{ secrets.PUBLIC_IP }}
  TF_VAR_skip_k3s_resources: "true"
  # Keep vault_enabled=true so existing vault resources in state aren't planned
  # for destruction. With -refresh=false, Vault won't be contacted.
  TF_VAR_skip_vault_resources: "false"
  TF_VAR_vault_token: "ci-placeholder"
  TF_VAR_kubeconfig_path: "~/.kube/config-eldertree"
  TF_VAR_pi_user: ${{ secrets.PI_USER }}

jobs:
  terraform:
    name: "Terraform"
    runs-on: ubuntu-latest
    environment: dev

    defaults:
      run:
        shell: bash
        working-directory: terraform

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          cli_config_credentials_hostname: app.terraform.io
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Terraform Init
        run: terraform init -input=false

      # Avoid piping terraform output through head/tail to prevent EPIPE
      # crashes with the setup-terraform Node.js wrapper
      - name: Verify Remote State
        run: |
          if terraform state list > state-list.txt 2>&1; then
            STATE_COUNT=$(wc -l < state-list.txt | tr -d ' ')
            echo "✅ Remote state: $STATE_COUNT resources"
            head -20 state-list.txt
            [ "$STATE_COUNT" -gt 20 ] && echo "... and $((STATE_COUNT - 20)) more"
            if [ "$STATE_COUNT" -eq "0" ]; then
              echo "❌ State is empty - failing to prevent accidental recreation"
              exit 1
            fi
          else
            echo "❌ Could not access remote state"
            cat state-list.txt 2>/dev/null || true
            exit 1
          fi
          rm -f state-list.txt

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      # -refresh=false: skip provider connections for state refresh
      # Required because Vault resources exist in state but CI can't reach Vault
      - name: Terraform Plan
        id: plan
        run: |
          set +e
          terraform plan -input=false -refresh=false -detailed-exitcode > plan-output.txt 2>&1
          PLAN_EXIT_CODE=$?
          set -e
          cat plan-output.txt
          echo ""
          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "✅ No changes needed"
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "✅ Changes detected"
            grep -A 5 "Plan:" plan-output.txt || true
          else
            echo "❌ Plan failed (exit code $PLAN_EXIT_CODE)"
            exit 1
          fi

      - name: Terraform Apply
        if: |
          steps.plan.outcome == 'success' && 
          (github.event_name == 'workflow_dispatch' && github.event.inputs.apply == 'true')
        run: terraform apply -auto-approve -input=false -refresh=false
